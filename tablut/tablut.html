<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Királyszöktetés (Tablut)</title>
<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: #333;
        color: #fff;
        padding: 20px 0;
    }
    #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    #board {
        display: grid;
        grid-template-columns: repeat(9, 55px);
        grid-template-rows: repeat(9, 55px);
        border: 3px solid #8B4513;
        background-color: #DEB887;
    }
    .square {
        width: 55px;
        height: 55px;
        box-sizing: border-box;
        border: 1px solid #8B4513;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    .castle { /* A középső mező */
        background-color: #A0522D;
    }
    .piece {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
    }
    .muscovite { /* Támadók */
        background-color: #2c3e50;
    }
    .swede { /* Védők */
        background-color: #ecf0f1;
    }
    .king {
        background-color: #f1c40f;
        position: relative;
    }
    .king::before {
        content: '+'; color: #2c3e50; font-weight: bold; font-size: 30px;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    .selected {
        outline: 3px solid #3498db;
        outline-offset: -3px;
    }
    .possible-move {
        background-color: rgba(52, 152, 219, 0.5);
    }
    #info-panel {
        margin-top: 20px;
        text-align: center;
        min-height: 100px;
    }
    h1 { margin-bottom: 10px; }
    #turn-indicator { font-size: 1.2em; margin-bottom: 10px; }
    #warning-indicator {
        font-size: 1.1em; color: #f1c40f; font-weight: bold;
        height: 25px; margin-bottom: 10px;
    }
    .button-group { display: flex; gap: 10px; }
    .game-button {
        padding: 10px 20px; font-size: 1em; cursor: pointer;
        border: none; border-radius: 5px; background-color: #3498db; color: white;
    }
    /* Szabályok ablak (Modal) */
    .modal {
        display: none; position: fixed; z-index: 10;
        left: 0; top: 0; width: 100%; height: 100%;
        overflow: auto; background-color: rgba(0,0,0,0.6);
    }
    .modal-content {
        background-color: #fefefe; color: #333;
        margin: 10% auto; padding: 20px; border: 1px solid #888;
        width: 80%; max-width: 600px; border-radius: 10px;
        line-height: 1.6;
    }
    .modal-content h2 { margin-top: 0; }
    .close-button {
        color: #aaa; float: right; font-size: 28px; font-weight: bold;
    }
    .close-button:hover, .close-button:focus {
        color: black; text-decoration: none; cursor: pointer;
    }
</style>
</head>
<body>

<div id="game-container">
    <h1>Tablut</h1>
    <div id="board"></div>
    <div id="info-panel">
        <div id="turn-indicator"></div>
        <div id="warning-indicator"></div>
        <div class="button-group">
            <button id="reset-button" class="game-button">Új játék</button>
            <button id="rules-button" class="game-button">Szabályok</button>
        </div>
    </div>
</div>

<div id="rules-modal" class="modal">
    <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>Tablut Játékszabályok</h2>
        <p><strong>Cél:</strong></p>
        <ul>
            <li><strong>Svédek (világos):</strong> A királynak el kell érnie a tábla bármelyik szélén lévő mezőt.</li>
            <li><strong>Moszkoviták (sötét):</strong> El kell fogni a királyt.</li>
        </ul>
        <p><strong>Lépések:</strong></p>
        <ul>
            <li>Minden bábu (a király is) vízszintesen vagy függőlegesen léphet bármennyi üres mezőt, mint a bástya a sakkban.</li>
            <li>Más bábukat átugrani tilos.</li>
        </ul>
        <p><strong>Leütés:</strong></p>
        <ul>
            <li>Egy ellenséges bábut (nem a királyt) akkor lehet levenni, ha két ellentétes oldalról közrefogjuk a saját bábunkkal (vízszintesen vagy függőlegesen).</li>
            <li>Az üres trón "ellenséges" mezőnek számít, tehát egy bábu és a trón közé szorított figura is le van ütve.</li>
        </ul>
        <p><strong>A Király Elfogása:</strong></p>
        <ul>
            <li>Ha a király távol van a tróntól, ugyanúgy fogható el, mint bármely más védő: két moszkovita bábuval kell közrefogni.</li>
            <li><strong>Kivételek:</strong> A trón és környéke biztonságosabb a király számára.
                <ul>
                    <li>Ha a király a <strong>trón melletti</strong> mezőn áll, három oldalról kell bekeríteni.</li>
                    <li>Ha a király a <strong>trónon</strong> van, mind a négy oldalról be kell keríteni az elfogásához.</li>
                </ul>
            </li>
            <li><strong>Fontos:</strong> Ha a király egyszer elhagyta a trónt, többé nem léphet vissza rá.</li>
        </ul>
         <p><strong>Figyelmeztetések:</strong></p>
        <ul>
            <li>A világos játékos lépése után, ha a királynak egy szabad útja van a szélre, a "Rájgge!" felirat jelenik meg.</li>
            <li>Ha kettő vagy több útja van, a "Dujgu!" felirat látható.</li>
        </ul>
    </div>
</div>


<script>
document.addEventListener('DOMContentLoaded', () => {
    // Játék elemek
    const boardElement = document.getElementById('board');
    const turnIndicator = document.getElementById('turn-indicator');
    const warningIndicator = document.getElementById('warning-indicator');
    const resetButton = document.getElementById('reset-button');
    const rulesButton = document.getElementById('rules-button');
    
    // Szabályok ablak elemek
    const rulesModal = document.getElementById('rules-modal');
    const closeButton = document.querySelector('.close-button');

    const BOARD_SIZE = 9;
    const MUSCOVITE = 'muscovite';
    const SWEDE = 'swede';
    const KING = 'king';
    const CASTLE_POS = {r: 4, c: 4};

    let boardState = [];
    let currentPlayer = MUSCOVITE;
    let selectedPiece = null;
    let kingHasMovedFromThrone = false;
    let isGameOver = false;

    const initialSetup = () => [
        ['', '', '', MUSCOVITE, MUSCOVITE, MUSCOVITE, '', '', ''],
        ['', '', '', '', MUSCOVITE, '', '', '', ''],
        ['', '', '', '', SWEDE, '', '', '', ''],
        [MUSCOVITE, '', '', '', SWEDE, '', '', '', MUSCOVITE],
        [MUSCOVITE, MUSCOVITE, SWEDE, SWEDE, KING, SWEDE, SWEDE, MUSCOVITE, MUSCOVITE],
        [MUSCOVITE, '', '', '', SWEDE, '', '', '', MUSCOVITE],
        ['', '', '', '', SWEDE, '', '', '', ''],
        ['', '', '', '', MUSCOVITE, '', '', '', ''],
        ['', '', '', MUSCOVITE, MUSCOVITE, MUSCOVITE, '', '', '']
    ];
    
    function initGame() {
        boardState = initialSetup();
        currentPlayer = MUSCOVITE;
        selectedPiece = null;
        kingHasMovedFromThrone = false;
        isGameOver = false;
        renderBoard();
        updateTurnIndicator();
        warningIndicator.textContent = '';
    }

    function renderBoard() {
        boardElement.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const square = document.createElement('div');
                square.classList.add('square');
                square.dataset.r = r;
                square.dataset.c = c;
                if (isCastle(r, c)) square.classList.add('castle');
                
                const pieceType = boardState[r][c];
                if (pieceType) {
                    const piece = document.createElement('div');
                    piece.classList.add('piece', pieceType);
                    square.appendChild(piece);
                }
                square.addEventListener('click', () => onSquareClick(r, c));
                boardElement.appendChild(square);
            }
        }
    }
    
    function onSquareClick(r, c) {
        if (isGameOver) return;
        const pieceType = boardState[r][c];

        if (selectedPiece) {
            if (isValidMove(selectedPiece.r, selectedPiece.c, r, c)) {
                const movedPieceType = boardState[selectedPiece.r][selectedPiece.c];
                movePiece(selectedPiece.r, selectedPiece.c, r, c);
                checkForCaptures(r, c);
                if (checkForWin()) return;
                
                if (isAllied(SWEDE, movedPieceType)) {
                    checkForWarnings();
                }

                switchPlayer();
            }
            clearHighlights();
            selectedPiece = null;
        } else if (pieceType && isCurrentPlayerPiece(pieceType)) {
            selectedPiece = { r, c, type: pieceType };
            highlightSelected(r, c);
            highlightPossibleMoves(r, c);
        }
    }

    function movePiece(fromR, fromC, toR, toC) {
        const pieceType = boardState[fromR][fromC];
        if (pieceType === KING && isCastle(fromR, fromC)) {
            kingHasMovedFromThrone = true;
        }
        boardState[toR][toC] = pieceType;
        boardState[fromR][fromC] = '';
    }

    function switchPlayer() {
        currentPlayer = (currentPlayer === MUSCOVITE) ? SWEDE : MUSCOVITE;
        updateTurnIndicator();
        if (currentPlayer === SWEDE) {
            warningIndicator.textContent = '';
        }
    }
    
    function isValidMove(fromR, fromC, toR, toC) {
        const pieceType = boardState[fromR][fromC];

        if (boardState[toR][toC] !== '') return false;
        if (fromR !== toR && fromC !== toC) return false;
        
        if (isCastle(toR, toC)) {
            if (pieceType !== KING || kingHasMovedFromThrone) return false;
        }
        
        const stepR = Math.sign(toR - fromR);
        const stepC = Math.sign(toC - fromC);
        let r = fromR + stepR;
        let c = fromC + stepC;
        while (r !== toR || c !== toC) {
            if (boardState[r][c] !== '') return false;
            r += stepR;
            c += stepC;
        }
        return true;
    }
    
    function checkForCaptures(r, c) {
        const movedPieceType = boardState[r][c];
        const neighbors = [[r-1, c], [r+1, c], [r, c-1], [r, c+1]];
        for (const [nr, nc] of neighbors) {
            if (isOutOfBounds(nr, nc)) continue;
            const neighborPiece = boardState[nr][nc];
            // Normál bábuk ütése
            if (neighborPiece && neighborPiece !== KING && !isAllied(movedPieceType, neighborPiece)) {
                const [or, oc] = [nr + (nr - r), nc + (nc - c)];
                if (isCapturingSquare(or, oc, movedPieceType)) {
                    boardState[nr][nc] = '';
                }
            }
        }
        renderBoard();
    }
    
    function isCapturingSquare(r, c, capturingPieceType) {
        if (isOutOfBounds(r, c)) return false;
        const targetSquareContent = boardState[r][c];
        if (isCastle(r, c)) {
            if (targetSquareContent === '' || targetSquareContent === KING) return true;
        }
        return isAllied(capturingPieceType, targetSquareContent);
    }
    
    // A KIRÁLY ELFOGÁSÁNAK JAVÍTOTT, TÖBBLÉPCSŐS LOGIKÁJA
    function isKingCaptured() {
        const kingPos = findKing();
        if (!kingPos) return true;

        const { r, c } = kingPos;

        // 1. Eset: A király a trónon van -> 4 oldalról kell bekeríteni
        if (isCastle(r, c)) {
            const surroundings = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
            let hostileSides = 0;
            for (const [nr, nc] of surroundings) {
                if (!isOutOfBounds(nr, nc) && boardState[nr][nc] === MUSCOVITE) {
                    hostileSides++;
                }
            }
            return hostileSides === 4;
        }

        // 2. Eset: A király a trón mellett van -> 3 oldalról kell bekeríteni
        if (isAdjacentToCastle(r, c)) {
            const surroundings = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
            let hostileSides = 0;
            for (const [nr, nc] of surroundings) {
                if (isCastle(nr, nc)) continue; // A trón oldalát nem számoljuk
                if (isOutOfBounds(nr, nc) || boardState[nr][nc] === MUSCOVITE) {
                    hostileSides++;
                }
            }
            return hostileSides === 3;
        }

        // 3. Eset: A király bárhol máshol van -> normál 2-oldalas szendvics-ütés
        const leftPiece = isOutOfBounds(r, c - 1) ? null : boardState[r][c - 1];
        const rightPiece = isOutOfBounds(r, c + 1) ? null : boardState[r][c + 1];
        if (leftPiece === MUSCOVITE && rightPiece === MUSCOVITE) {
            return true;
        }
        const topPiece = isOutOfBounds(r - 1, c) ? null : boardState[r - 1][c];
        const bottomPiece = isOutOfBounds(r + 1, c) ? null : boardState[r + 1][c];
        if (topPiece === MUSCOVITE && bottomPiece === MUSCOVITE) {
            return true;
        }

        return false;
    }
    
    function checkForWin() {
        const kingPos = findKing();
        if (kingPos && isEdge(kingPos.r, kingPos.c)) {
            announceWinner(SWEDE);
            return true;
        }
        if (isKingCaptured()) {
            announceWinner(MUSCOVITE);
            return true;
        }
        return false;
    }
    
    function announceWinner(winner) {
        isGameOver = true;
        const winnerName = winner === MUSCOVITE ? "Moszkoviták (sötét)" : "Svédek (világos)";
        setTimeout(() => {
            alert(`${winnerName} győztek!`);
            initGame();
        }, 100);
    }
    
    function checkForWarnings() {
        const kingPos = findKing();
        if (!kingPos) return;
        let escapeRoutes = 0;
        const checkEdge = (r, c) => {
            if(isValidMove(kingPos.r, kingPos.c, r, c)) escapeRoutes++;
        };
        for (let i = 0; i < BOARD_SIZE; i++) {
            checkEdge(0, i);
            checkEdge(BOARD_SIZE - 1, i);
            if (i > 0 && i < BOARD_SIZE - 1) {
                checkEdge(i, 0);
                checkEdge(i, BOARD_SIZE - 1);
            }
        }
        if (escapeRoutes >= 2) {
            warningIndicator.textContent = 'Dujgu!';
        } else if (escapeRoutes === 1) {
            warningIndicator.textContent = 'Rájgge!';
        }
    }

    // Segédfüggvények
    function isCastle(r, c) { return r === CASTLE_POS.r && c === CASTLE_POS.c; }
    function isEdge(r, c) { return r === 0 || r === BOARD_SIZE - 1 || c === 0 || c === BOARD_SIZE - 1; }
    function isOutOfBounds(r, c) { return r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE; }
    function isAdjacentToCastle(r, c) { return Math.abs(r - CASTLE_POS.r) + Math.abs(c - CASTLE_POS.c) === 1; }
    function isAllied(p1, p2) {
        if (!p1 || !p2) return false;
        if (p1 === MUSCOVITE) return p2 === MUSCOVITE;
        if (p1 === SWEDE || p1 === KING) return p2 === SWEDE || p2 === KING;
        return false;
    }
    function isCurrentPlayerPiece(pieceType) { return isAllied(currentPlayer, pieceType); }
    function findKing() {
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (boardState[r][c] === KING) return {r, c};
            }
        }
        return null;
    }

    // UI Függvények
    function updateTurnIndicator() {
        const playerName = currentPlayer === MUSCOVITE ? "Moszkoviták (sötét)" : "Svédek (világos)";
        turnIndicator.textContent = `A ${playerName} következnek.`;
    }
    function clearHighlights() {
        document.querySelectorAll('.selected, .possible-move').forEach(el => {
            el.classList.remove('selected', 'possible-move');
        });
    }
    function highlightSelected(r, c) {
        clearHighlights();
        const square = document.querySelector(`[data-r='${r}'][data-c='${c}']`);
        if(square && square.firstChild) square.firstChild.classList.add('selected');
    }
    function highlightPossibleMoves(r, c) {
        for (let i = 0; i < BOARD_SIZE; i++) {
            if (isValidMove(r, c, r, i)) document.querySelector(`[data-r='${r}'][data-c='${i}']`).classList.add('possible-move');
            if (isValidMove(r, c, i, c)) document.querySelector(`[data-r='${i}'][data-c='${c}']`).classList.add('possible-move');
        }
    }

    // Eseménykezelők
    resetButton.addEventListener('click', initGame);
    rulesButton.addEventListener('click', () => { rulesModal.style.display = 'block'; });
    closeButton.addEventListener('click', () => { rulesModal.style.display = 'none'; });
    window.addEventListener('click', (event) => {
        if (event.target == rulesModal) {
            rulesModal.style.display = 'none';
        }
    });

    // Játék indítása
    initGame();
});
</script>

</body>
</html>
