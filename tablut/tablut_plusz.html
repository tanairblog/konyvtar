<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tablut</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
<style>
    :root {
        --board-bg: #e3d5b8;
        --dark-piece: #1a1a1a;
        --throne-color: #c88175;
        --border-color: #5c4d3d;
        --text-color: #e3d5b8;
        --title-color: #ffd700;
        --dark-bg: #212121;
    }
    body {
        font-family: 'Cinzel', serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background-color: var(--dark-bg);
        color: var(--text-color);
        padding: 20px 0;
    }
    #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-shadow: 1px 1px 3px #000;
    }
    #board {
        display: grid;
        grid-template-columns: repeat(9, 60px);
        grid-template-rows: repeat(9, 60px);
        border: 4px solid var(--border-color);
        background-color: var(--board-bg);
        box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 0 10px rgba(0,0,0,0.3);
        padding: 5px;
        border-radius: 4px;
    }
    .square {
        width: 60px;
        height: 60px;
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        border-right: 1px solid #cbbba1;
        border-bottom: 1px solid #cbbba1;
        position: relative;
    }
    .special-marker {
        position: absolute;
        font-size: 30px;
        color: rgba(0,0,0,0.15);
        z-index: 0;
    }
    .castle, .corner {
        background-color: rgba(0,0,0,0.05);
    }
    .castle { background-color: var(--throne-color); }
    .piece {
        width: 80%;
        height: 80%;
        z-index: 1;
        transition: transform 0.1s ease-in-out;
        filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.4));
    }
    .piece:hover { transform: scale(1.1); }
    .muscovite svg, .swede svg, .king svg {
        stroke: #1a1a1a;
        stroke-width: 5;
        stroke-linejoin: round;
    }
    .muscovite svg { fill: #2c3e50; }
    .swede svg { fill: #FFFFFF; }
    .king svg { fill: var(--title-color); }
    
    .selected {
        filter: drop-shadow(0 0 8px #00aaff) drop-shadow(2px 3px 4px rgba(0,0,0,0.4));
        transform: scale(1.1);
    }
    .possible-move::after {
        content: '';
        position: absolute;
        width: 25%;
        height: 25%;
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 50%;
        z-index: 2;
    }
    #info-panel { margin-top: 25px; text-align: center; }
    h1 { margin-bottom: 15px; font-weight: 700; font-size: 3em; color: var(--title-color); }
    #turn-indicator { font-size: 1.4em; margin-bottom: 15px; }
    #warning-indicator {
        font-size: 1.2em; color: #ff4d4d; font-weight: bold;
        height: 25px; margin-bottom: 15px;
    }
    .button-group { display: flex; gap: 15px; }
    .game-button {
        font-family: 'Cinzel', serif;
        padding: 12px 24px; font-size: 1em; cursor: pointer;
        border: 2px solid var(--text-color); border-radius: 5px; 
        background-color: transparent; color: var(--text-color);
        transition: all 0.2s ease;
    }
    .game-button:hover {
        background-color: var(--text-color); color: var(--dark-bg);
        box-shadow: 0 0 10px var(--text-color);
    }
    .modal {
        display: none; position: fixed; z-index: 10;
        left: 0; top: 0; width: 100%; height: 100%;
        overflow: auto; background-color: rgba(0,0,0,0.8);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .modal-content {
        background-color: #f0e6d2; color: #333;
        margin: 10% auto; padding: 25px; border: 2px solid #382d21;
        width: 80%; max-width: 600px; border-radius: 10px;
        line-height: 1.6; box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    }
    .modal-content h2 { margin-top: 0; font-family: 'Cinzel', serif; }
    .close-button {
        color: #aaa; float: right; font-size: 28px; font-weight: bold;
    }
    .close-button:hover, .close-button:focus {
        color: black; text-decoration: none; cursor: pointer;
    }
</style>
</head>
<body>

<div id="game-container">
    <h1>Tablut</h1>
    <div id="board"></div>
    <div id="info-panel">
        <div id="turn-indicator"></div>
        <div id="warning-indicator"></div>
        <div class="button-group">
            <button id="reset-button" class="game-button">Új játék</button>
            <button id="rules-button" class="game-button">Szabályok</button>
        </div>
    </div>
</div>

<audio id="muscovite-move-sound" src="https://bigsoundbank.com/UPLOAD/mp3/1319.mp3" preload="auto"></audio>
<audio id="swede-move-sound" src="https://bigsoundbank.com/UPLOAD/mp3/1845.mp3" preload="auto"></audio>
<audio id="capture-sound" src="https://bigsoundbank.com/UPLOAD/mp3/0129.mp3" preload="auto"></audio>
<audio id="king-move-sound" src="kiraly.mp3" preload="auto"></audio>

<div id="rules-modal" class="modal">
    <div class="modal-content">
        <span class="close-button">&times;</span>
        <h2>Tablut Játékszabályok</h2>
        <p><strong>Cél:</strong></p>
        <ul>
            <li><strong>Svédek (pajzs):</strong> A királynak el kell érnie a tábla bármelyik <strong>szélső mezőjét</strong>.</li>
            <li><strong>Moszkoviták (sisak):</strong> El kell fogni a királyt.</li>
        </ul>
        <p><strong>Lépések:</strong></p>
        <ul>
            <li>Minden bábu (a király is) vízszintesen vagy függőlegesen léphet bármennyi üres mezőt, mint a bástya a sakkban.</li>
            <li>Más bábukat átugrani tilos.</li>
        </ul>
        <p><strong>Leütés:</strong></p>
        <ul>
            <li>Egy ellenséges bábut (nem a királyt) akkor lehet levenni, ha egy **ellenséges lépés** után két ellentétes oldalról közrefogják. Egy bábu nem léphet be a saját vesztébe.</li>
            <li>Az üres trón és a sarokmezők "ellenségesnek" számítanak, tehát egy bábu és ezen mezők közé szorított figura is le van ütve.</li>
        </ul>
        <p><strong>A Király Elfogása:</strong></p>
        <ul>
            <li>Ha a király távol van a tróntól, egy **moszkovita lépésnek** kell létrehoznia a kétoldali közrefogást.</li>
            <li><strong>Kivételek:</strong> A trón és környéke biztonságosabb a király számára.
                <ul>
                    <li>Ha a király a <strong>trón melletti</strong> mezőn áll, egy moszkovita lépésnek kell bekerítenie három oldalról.</li>
                    <li>Ha a király a <strong>trónon</strong> van, egy moszkovita lépésnek kell bekerítenie mind a négy oldalról.</li>
                </ul>
            </li>
            <li><strong>Fontos:</strong> Ha a király egyszer elhagyta a várat, többé nem léphet vissza rá.</li>
        </ul>
         <p><strong>Figyelmeztetések:</strong></p>
        <ul>
            <li>A világos játékos lépése után, ha a királynak egy szabad útja van a szélre, a "Rájgge!" felirat jelenik meg.</li>
            <li>Ha kettő vagy több útja van, a "Dujgu!" felirat látható.</li>
        </ul>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // Játék elemek
    const boardElement = document.getElementById('board');
    const turnIndicator = document.getElementById('turn-indicator');
    const warningIndicator = document.getElementById('warning-indicator');
    const resetButton = document.getElementById('reset-button');
    const rulesButton = document.getElementById('rules-button');
    const captureSound = document.getElementById('capture-sound');
    const muscoviteMoveSound = document.getElementById('muscovite-move-sound');
    const swedeMoveSound = document.getElementById('swede-move-sound');
    const kingMoveSound = document.getElementById('king-move-sound');
    
    const rulesModal = document.getElementById('rules-modal');
    const closeButton = document.querySelector('.close-button');

    const BOARD_SIZE = 9;
    const MUSCOVITE = 'muscovite';
    const SWEDE = 'swede';
    const KING = 'king';
    const CASTLE_POS = {r: 4, c: 4};
    const CORNER_POS = [{r:0,c:0},{r:0,c:8},{r:8,c:0},{r:8,c:8}];

    let boardState = [];
    let currentPlayer = MUSCOVITE;
    let selectedPiece = null;
    let kingHasMovedFromThrone = false;
    let isGameOver = false;
    let soundTimeout = null; // Időzítő a hangok leállításához

    // ÚJRATERVEZETT SVG IKONOK
    const pieceSVG = {
        muscovite: `<svg class="piece muscovite" viewBox="0 0 100 100"><path d="M 50 20 C 40 20, 25 30, 25 50 L 25 80 L 75 80 L 75 50 C 75 30, 60 20, 50 20 Z M 45 40 L 55 40 L 55 65 L 45 65 Z"/></svg>`,
        swede: `<svg class="piece swede" viewBox="0 0 100 100"><path d="M 50 15 L 85 40 L 85 70 L 50 90 L 15 70 L 15 40 Z M 50 50 m -10, 0 a 10,10 0 1,0 20,0 a 10,10 0 1,0 -20,0"/></svg>`,
        king: `<svg class="piece king" viewBox="0 0 100 100"><path d="M 50 35 C 40 35, 25 45, 25 65 L 25 90 L 75 90 L 75 65 C 75 45, 60 35, 50 35 Z M 50 5 L 65 30 L 35 30 Z M 25 20 L 40 30 M 75 20 L 60 30"/></svg>`
    };

    const initialSetup = () => [
        ['', '', '', MUSCOVITE, MUSCOVITE, MUSCOVITE, '', '', ''],
        ['', '', '', '', MUSCOVITE, '', '', '', ''],
        ['', '', '', '', SWEDE, '', '', '', ''],
        [MUSCOVITE, '', '', '', SWEDE, '', '', '', MUSCOVITE],
        [MUSCOVITE, MUSCOVITE, SWEDE, SWEDE, KING, SWEDE, SWEDE, MUSCOVITE, MUSCOVITE],
        [MUSCOVITE, '', '', '', SWEDE, '', '', '', MUSCOVITE],
        ['', '', '', '', SWEDE, '', '', '', ''],
        ['', '', '', '', MUSCOVITE, '', '', '', ''],
        ['', '', '', MUSCOVITE, MUSCOVITE, MUSCOVITE, '', '', '']
    ];
    
    // Segédfüggvény a hangok lejátszásához és leállításához
    function playSound(audioElement, duration) {
        if (soundTimeout) clearTimeout(soundTimeout);
        
        [muscoviteMoveSound, swedeMoveSound, kingMoveSound, captureSound].forEach(sound => {
            sound.pause();
            sound.currentTime = 0;
        });

        audioElement.currentTime = 0;
        audioElement.play();

        soundTimeout = setTimeout(() => {
            audioElement.pause();
            audioElement.currentTime = 0;
        }, duration);
    }

    function initGame() {
        boardState = initialSetup();
        currentPlayer = MUSCOVITE;
        selectedPiece = null;
        kingHasMovedFromThrone = false;
        isGameOver = false;
        renderBoard();
        updateTurnIndicator();
        warningIndicator.textContent = '';
    }

    function renderBoard() {
        boardElement.innerHTML = '';
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const square = document.createElement('div');
                square.classList.add('square');
                square.dataset.r = r;
                square.dataset.c = c;
                if (isCastle(r, c)) square.classList.add('castle');
                if (isCorner(r,c)) square.classList.add('corner');
                
                if (isCastle(r, c) || isCorner(r,c)) {
                    const marker = document.createElement('div');
                    marker.classList.add('special-marker');
                    marker.textContent = '※';
                    square.appendChild(marker);
                }
                
                const pieceType = boardState[r][c];
                if (pieceType) {
                    square.innerHTML += pieceSVG[pieceType];
                }
                square.addEventListener('click', () => onSquareClick(r, c));
                boardElement.appendChild(square);
            }
        }
    }
    
    function onSquareClick(r, c) {
        if (isGameOver) return;
        if (selectedPiece) {
            if (isValidMove(selectedPiece.r, selectedPiece.c, r, c)) {
                const movedPieceType = boardState[selectedPiece.r][selectedPiece.c];
                
                movePiece(selectedPiece.r, selectedPiece.c, r, c);
                const wasRegularCapture = checkForCaptures(r, c);
                const wasKingCaptured = (movedPieceType === MUSCOVITE && isKingCaptured());

                // Hangok lejátszása a központi logikával
                if (wasKingCaptured || wasRegularCapture) {
                    playSound(captureSound, 2000);
                } else {
                    if (movedPieceType === KING) {
                        playSound(kingMoveSound, 2000);
                    } else if (movedPieceType === MUSCOVITE) {
                        playSound(muscoviteMoveSound, 2000);
                    } else if (isAllied(SWEDE, movedPieceType)) {
                        playSound(swedeMoveSound, 2000);
                    }
                }
                
                renderBoard();

                // Győzelem ellenőrzése
                if (wasKingCaptured) {
                    announceWinner(MUSCOVITE);
                    return;
                }
                const kingPos = findKing();
                if (kingPos && isEdge(kingPos.r, kingPos.c)) {
                    announceWinner(SWEDE);
                    return;
                }
                
                if (isAllied(SWEDE, movedPieceType)) {
                    checkForWarnings();
                }

                switchPlayer();
            }
            clearHighlights();
            selectedPiece = null;
        } else {
            const pieceType = boardState[r][c];
            if (pieceType && isCurrentPlayerPiece(pieceType)) {
                selectedPiece = { r, c, type: pieceType };
                highlightSelected(r, c);
                highlightPossibleMoves(r, c);
            }
        }
    }

    function movePiece(fromR, fromC, toR, toC) {
        const pieceType = boardState[fromR][fromC];
        if (pieceType === KING && isCastle(fromR, fromC)) {
            kingHasMovedFromThrone = true;
        }
        boardState[toR][toC] = pieceType;
        boardState[fromR][fromC] = '';
    }

    function switchPlayer() {
        currentPlayer = (currentPlayer === MUSCOVITE) ? SWEDE : MUSCOVITE;
        updateTurnIndicator();
        if (currentPlayer === SWEDE) {
            warningIndicator.textContent = '';
        }
    }
    
    function isValidMove(fromR, fromC, toR, toC) {
        const pieceType = boardState[fromR][fromC];
        if (boardState[toR][toC] !== '') return false;
        if (fromR !== toR && fromC !== toC) return false;
        if (isCorner(toR,toC) && pieceType !== KING) return false;
        if (isCastle(toR, toC)) {
            if (pieceType !== KING || kingHasMovedFromThrone) return false;
        }
        const stepR = Math.sign(toR - fromR);
        const stepC = Math.sign(toC - fromC);
        let r = fromR + stepR;
        let c = fromC + stepC;
        while (r !== toR || c !== toC) {
            if (boardState[r][c] !== '') return false;
            r += stepR;
            c += stepC;
        }
        return true;
    }
    
    function checkForCaptures(r, c) {
        let pieceWasCaptured = false;
        const movedPieceType = boardState[r][c];
        const neighbors = [[r-1, c], [r+1, c], [r, c-1], [r, c+1]];
        for (const [nr, nc] of neighbors) {
            if (isOutOfBounds(nr, nc)) continue;
            const neighborPiece = boardState[nr][nc];
            if (neighborPiece && neighborPiece !== KING && !isAllied(movedPieceType, neighborPiece)) {
                const [or, oc] = [nr + (nr - r), nc + (nc - c)];
                if (isCapturingSquare(or, oc, movedPieceType)) {
                    boardState[nr][nc] = '';
                    pieceWasCaptured = true;
                }
            }
        }
        return pieceWasCaptured;
    }
    
    function isCapturingSquare(r, c, capturingPieceType) {
        if (isOutOfBounds(r, c)) return false;
        const targetSquareContent = boardState[r][c];
        if (isCastle(r, c) || isCorner(r,c)) {
            if (targetSquareContent === '' || targetSquareContent === KING) return true;
        }
        return isAllied(capturingPieceType, targetSquareContent);
    }
    
    function isKingCaptured() {
        const kingPos = findKing();
        if (!kingPos) return true;
        const { r, c } = kingPos;
        if (isCastle(r, c)) {
            const surroundings = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
            let hostileSides = 0;
            for (const [nr, nc] of surroundings) {
                if (!isOutOfBounds(nr, nc) && boardState[nr][nc] === MUSCOVITE) hostileSides++;
            }
            return hostileSides === 4;
        }
        if (isAdjacentToCastle(r, c)) {
            const surroundings = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
            let hostileSides = 0;
            for (const [nr, nc] of surroundings) {
                if (isCastle(nr, nc)) continue;
                if (isOutOfBounds(nr, nc) || boardState[nr][nc] === MUSCOVITE) hostileSides++;
            }
            return hostileSides === 3;
        }
        const leftPiece = isOutOfBounds(r, c - 1) ? null : boardState[r][c - 1];
        const rightPiece = isOutOfBounds(r, c + 1) ? null : boardState[r][c + 1];
        if (leftPiece === MUSCOVITE && rightPiece === MUSCOVITE) return true;
        const topPiece = isOutOfBounds(r - 1, c) ? null : boardState[r - 1][c];
        const bottomPiece = isOutOfBounds(r + 1, c) ? null : boardState[r + 1][c];
        if (topPiece === MUSCOVITE && bottomPiece === MUSCOVITE) return true;
        return false;
    }
    
    function announceWinner(winner) {
        isGameOver = true;
        const winnerName = winner === MUSCOVITE ? "Moszkoviták" : "Svédek";
        setTimeout(() => {
            alert(`${winnerName} győztek!`);
            initGame();
        }, 100);
    }
    
    function checkForWarnings() {
        const kingPos = findKing();
        if (!kingPos) return;
        let escapeRoutes = 0;
        const checkEdge = (r, c) => {
            if(isValidMove(kingPos.r, kingPos.c, r, c)) escapeRoutes++;
        };
        for (let i = 0; i < BOARD_SIZE; i++) {
            checkEdge(0, i); checkEdge(BOARD_SIZE - 1, i);
            if (i > 0 && i < BOARD_SIZE - 1) {
                checkEdge(i, 0); checkEdge(i, BOARD_SIZE - 1);
            }
        }
        if (escapeRoutes >= 2) {
            warningIndicator.textContent = 'Dujgu!';
        } else if (escapeRoutes === 1) {
            warningIndicator.textContent = 'Rájgge!';
        }
    }

    function isCastle(r, c) { return r === CASTLE_POS.r && c === CASTLE_POS.c; }
    function isCorner(r, c) { return CORNER_POS.some(pos => pos.r === r && pos.c === c); }
    function isEdge(r, c) { return r === 0 || r === BOARD_SIZE - 1 || c === 0 || c === BOARD_SIZE - 1; }
    function isOutOfBounds(r, c) { return r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE; }
    function isAdjacentToCastle(r, c) { return Math.abs(r - CASTLE_POS.r) + Math.abs(c - CASTLE_POS.c) === 1; }
    function isAllied(p1, p2) {
        if (!p1 || !p2) return false;
        if (p1 === MUSCOVITE) return p2 === MUSCOVITE;
        if (p1 === SWEDE || p1 === KING) return p2 === SWEDE || p2 === KING;
        return false;
    }
    function isCurrentPlayerPiece(pieceType) { return isAllied(currentPlayer, pieceType); }
    function findKing() {
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (boardState[r][c] === KING) return {r, c};
            }
        }
        return null;
    }

    function updateTurnIndicator() {
        const playerName = currentPlayer === MUSCOVITE ? "Moszkoviták (sisak)" : "Svédek (pajzs)";
        turnIndicator.textContent = `A ${playerName} következnek.`;
    }
    function clearHighlights() {
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.possible-move').forEach(el => el.classList.remove('possible-move'));
    }
    function highlightSelected(r, c) {
        clearHighlights();
        const square = document.querySelector(`[data-r='${r}'][data-c='${c}']`);
        if(square.querySelector('.piece')) square.querySelector('.piece').classList.add('selected');
    }
    function highlightPossibleMoves(r, c) {
        for (let i = 0; i < BOARD_SIZE; i++) {
            if (isValidMove(r, c, r, i)) document.querySelector(`[data-r='${r}'][data-c='${i}']`).classList.add('possible-move');
            if (isValidMove(r, c, i, c)) document.querySelector(`[data-r='${i}'][data-c='${c}']`).classList.add('possible-move');
        }
    }

    resetButton.addEventListener('click', initGame);
    rulesButton.addEventListener('click', () => { rulesModal.style.display = 'block'; });
    closeButton.addEventListener('click', () => { rulesModal.style.display = 'none'; });
    window.addEventListener('click', (event) => {
        if (event.target == rulesModal) {
            rulesModal.style.display = 'none';
        }
    });

    initGame();
});
</script>

</body>
</html>